name: IM Base service CICD workflow for build and deploy

on:
  push:
    branches: [ main, feature/**, 'release/**' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  JAVA_VERSION: '21'
  REGISTRY: ${{ secrets.DEV_DOCKER_REGISTRY_URL }}
  IMAGE_NAME: imbase-service

jobs:
  build-and-test:
    name: Build and Test
    runs-on: [telia-managed-medium]
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Extract version
        id: version
        run: |
          VERSION=$(./gradlew properties -q | grep "^version:" | awk '{print $2}')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Run Unit Tests
        run: ./gradlew test

      # - name: Upload Test Coverage
      #   uses: codecov/codecov-action@v4
      #   with:
      #     files: build/reports/jacoco/test/jacocoTestReport.xml
      #     flags: unittests
      #     name: codecov-umbrella

  code-quality-scan:
    name: Code Quality Scan
    runs-on: [telia-managed-medium]
    needs: build-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Cache SonarCloud packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: SonarQube Scan
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          ./gradlew sonar \
            -Dsonar.projectKey=${{ github.repository_owner }}_${{ github.event.repository.name }} \
            -Dsonar.organization=${{ github.repository_owner }} \
            -Dsonar.host.url=${SONAR_HOST_URL}

      - name: Checkstyle
        run: ./gradlew checkstyleMain checkstyleTest

      - name: SpotBugs
        run: ./gradlew spotbugsMain spotbugsTest

  security-scan:
    name: Security Scanning
    runs-on: [telia-managed-medium]
    needs: build-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: OWASP Dependency Check
        run: |
          ./gradlew dependencyCheckAnalyze \
            --info

      - name: Upload Dependency Check Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-report
          path: build/reports/dependency-check-report.html


  secrets-scan:
    name: Secrets Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GitLeaks Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker-build-push:
    name: Docker Build and Push
    runs-on:  [telia-managed-medium]
    needs: [build-and-test, code-quality-scan, security-scan, secrets-scan]
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.set-tag.outputs.image_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: spring-boot-app
          path: build/libs/

      - name: Determine environment and set image tag
        id: set-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="prod"
          elif [[ "${{ github.ref }}" == "refs/heads/feature/*" ]]; then
            ENV="dev"
          elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            ENV="staging"
          else
            ENV="dev"
          fi
          
          IMAGE_TAG="${ENV}-${SHORT_SHA}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Image tag will be: ${IMAGE_TAG}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.environment }}-latest
    

      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.image_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/feature/*'
    environment:
      name: dev
      url: https://dev.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_DEV }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ github.event.repository.name }} ./helm-chart \
            --namespace dev \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.docker-build-push.outputs.image_tag }} \
            --set environment=dev \
            --set replicaCount=2 \
            --values ./helm-chart/values-dev.yaml \
            --wait \
            --timeout 5m

      - name: Verify Deployment
        run: |
          kubectl rollout status deployment/${{ github.event.repository.name }} -n dev
          kubectl get pods -n dev -l app=${{ github.event.repository.name }}

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: startsWith(github.ref, 'refs/heads/release/')
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ github.event.repository.name }} ./helm-chart \
            --namespace staging \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.docker-build-push.outputs.image_tag }} \
            --set environment=staging \
            --set replicaCount=3 \
            --values ./helm-chart/values-staging.yaml \
            --wait \
            --timeout 5m

      - name: Run Smoke Tests
        run: |
          kubectl wait --for=condition=ready pod -l app=${{ github.event.repository.name }} -n staging --timeout=300s
          # Add your smoke test commands here

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://prod.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_PROD }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ github.event.repository.name }} ./helm-chart \
            --namespace production \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.docker-build-push.outputs.image_tag }} \
            --set environment=production \
            --set replicaCount=5 \
            --values ./helm-chart/values-prod.yaml \
            --wait \
            --timeout 10m

      - name: Verify Production Deployment
        run: |
          kubectl rollout status deployment/${{ github.event.repository.name }} -n production
          kubectl get pods -n production -l app=${{ github.event.repository.name }}

      - name: Run Health Checks
        run: |
          # Add production health check commands here
          echo "Production deployment successful"

      - name: Notify Deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: 'Production deployment ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}